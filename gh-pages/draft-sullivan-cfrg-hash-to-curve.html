<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head profile="http://www.w3.org/2006/03/hcard http://dublincore.org/documents/2008/08/04/dc-html/">
  <meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />

  <title>Hashing to Elliptic Curves</title>

  
<style type="text/css">/*<![CDATA[*/
@viewport {
  zoom: 1.0;
  width: extend-to-zoom;
}
@-ms-viewport {
  width: extend-to-zoom;
  zoom: 1.0;
}

@media screen and (min-width: 1024px) {
  body>ul.toc, body>#rfc\.toc {
    position: fixed;
    bottom: 0;
    right: 0;
    right: calc(50vw - 550px);
    width: 300px;
    z-index: 1;
  }
  #rfc\.toc {
    top: 55px;
    overflow: auto;
    overscroll-behavior: contain;
  }
  ul.toc, #rfc\.toc {
    overflow: auto;
    overscroll-behavior: contain;
  }
  body>ul.toc {
    top: 140px;
  }

  body {
    padding-right: 350px;
  }
}

body {
  font: 16px "Helvetica Neue",Helvetica,Arial,sans-serif;
  color: #333;
  font-size-adjust: 0.5;
  line-height: 24px;
  margin: 75px auto;
  max-width: 724px;
}

.title, .filename, h1, h2, h3, h4 {
  font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
  font-size-adjust: 0.5;
  font-weight: 500;
  color: #333;
  line-height: 100%;
  margin: 0.8em 0 0.3em;
}
.title { font-size: 36px; }
h1 { font-size: 36px; }
h2 { font-size: 24px; }
h3, h4 { font-size: 18px; }
h1 a[href], h2 a[href], h3 a[href], h4 a[href] {
  color: #333;
}

ul.toc li {
  list-style: none;
  text-indent: -2.5em;
  padding-left: 2.5em;
  padding-bottom: 5px;
  margin: 0;
}
ul.toc ul {
  margin: 0;
}
/* xml2rfc nests ul directly inside ul which messes with the style badly */
ul.toc, ul.toc>ul, ul.toc ul>ul {
  margin: 0 0 0 1.5em;
}

table {
  margin-left: 0em;
  border-collapse: collapse;
}
th {
  text-align: left;
  border-bottom: 2px solid #ddd;
}
td {
  border-top: 1px solid #ddd;
  vertical-align: top;
}
tr:nth-child(2n+1) > td,
tr:nth-child(2n+1) > th {
  background-color: #f9f9f9;
}
td.reference {
  max-width: 200px;
  border-top: none;
  padding-right: 1em;
}
.right {
  text-align: right;
}


table.header {
  width: 100%;
}
table.header td {
  border: none;
  background-color: transparent;
  color: black;
}
.filename {
  color: rgb(119, 119, 119);
  font-size: 23px;
  font-weight: normal;
  height: auto;
  line-height: 100%;
}
#rfc\.abstract+p, #rfc\.abstract p {
  font-size: 18px;
  line-height: 27px%;
}

samp, tt, code, pre {
  font: 11pt consolas, monospace;
  font-size-adjust: none;
}
pre {
  background-color: #eee;
  border: 1px solid #ddd;
  overflow-x: auto;
  padding: 5px;
  margin: 5px;
}
.figure {
  font-style: italic;
  margin: 0 1.5em;
}

address {
  margin: 10px 0 0;
}
.vcard {
  font-style: normal;
}
.vcardline {
  display: block;
}
.vcardline .fn {
  font-weight: bold;
}
.vcardline .hidden {
  display: none;
}

dl {
  margin-left: 1em;
}
dl.dl-horizontal: {
  margin-left: 0;
}
dl > dt {
  float: left;
  margin-right: 1em;
}
dl.nohang > dt {
  float: none;
}
dl > dd {
  margin-bottom: .5em;
}
dl.compact > dd {
  margin-bottom: 0em;
}
dl > dd > dl {
  margin-top: 0.5em;
  margin-bottom: 0em;
}
ul.empty {
  list-style-type: none;
}
ul.empty li {
  margin-top: .5em;
}

hr {
  border: 0;
  border-top: 1px solid #eee;
}
hr.noprint {
  display: none;
}

a {
  text-decoration: none;
}
a[href] {
  color: #2a6496;
}
a[href]:hover {
  background-color: #eee;
}

ol, ul, li, p {
  padding: 0;
  margin: 0.5em 0 0.5em 2em;
}
li, p {
  margin-left: 0;
}
address {
  font-style: normal;
}

.github-fork-ribbon-wrapper {
  display: none;
}
@media screen and (min-width: 800px) {
  /* "Fork me on GitHub" CSS ribbon based on
   * https://github.com/simonwhitaker/github-fork-ribbon-css
   */
  .github-fork-ribbon {
    position: absolute;
    padding: 2px 0;
    background-color: #a00;
    background-image: linear-gradient(to bottom, rgba(0, 0, 0, 0), rgba(0, 0, 0, 0.15));
    box-shadow: 0 2px 3px 0 rgba(0, 0, 0, 0.5);
    font: 700 12px "Helvetica Neue", Helvetica, Arial, sans-serif;

    pointer-events: auto;

    top: 38px;
    right: -45px;

    transform: rotate(45deg);
  }

  .github-fork-ribbon a[href],
  .github-fork-ribbon a[href]:hover {
    color: #fff;
    background-color: transparent;
    text-decoration: none;
    text-shadow: 0 -1px rgba(0, 0, 0, 0.5);
    text-align: center;

    width: 190px;
    line-height: 18px;

    display: inline-block;
    padding: 2px 0;

    border: 1.5px dotted #fff;
    border-color: rgba(255, 255, 255, 0.6);
  }

  .github-fork-ribbon-wrapper {
    display: block;
    width: 130px;
    height: 130px;
    position: absolute;
    overflow: hidden;
    top: 0; right: 0;
    z-index: 2;
    pointer-events: none;
  }
}
@media screen and (min-width: 1000px) {
  .github-fork-ribbon-wrapper {
    position: fixed;
  }
  /*]]>*/</style>


  <link href="#rfc.toc" rel="Contents">
<link href="#rfc.section.1" rel="Chapter" title="1 Introduction">
<link href="#rfc.section.1.1" rel="Chapter" title="1.1 Requirements">
<link href="#rfc.section.2" rel="Chapter" title="2 Algorithm Recommendations">
<link href="#rfc.section.3" rel="Chapter" title="3 Generic Interface">
<link href="#rfc.section.3.1" rel="Chapter" title="3.1 Utility Functions">
<link href="#rfc.section.4" rel="Chapter" title="4 Hashing Variants">
<link href="#rfc.section.4.1" rel="Chapter" title="4.1 Icart Method">
<link href="#rfc.section.4.2" rel="Chapter" title="4.2 Shallue-Woestijne-Ulas Method">
<link href="#rfc.section.4.3" rel="Chapter" title="4.3 Simplified SWU Method">
<link href="#rfc.section.4.4" rel="Chapter" title="4.4 Elligator2 Method">
<link href="#rfc.section.5" rel="Chapter" title="5 Curve Transformations">
<link href="#rfc.section.6" rel="Chapter" title="6 Cost Comparison">
<link href="#rfc.section.7" rel="Chapter" title="7 Security Considerations">
<link href="#rfc.section.8" rel="Chapter" title="8 Acknowledgements">
<link href="#rfc.section.9" rel="Chapter" title="9 Contributors">
<link href="#rfc.references" rel="Chapter" title="10 Normative References">
<link href="#rfc.appendix.A" rel="Chapter" title="A Try-and-Increment Method">
<link href="#rfc.appendix.B" rel="Chapter" title="B Sample Code">
<link href="#rfc.appendix.B.1" rel="Chapter" title="B.1 Icart Method">
<link href="#rfc.appendix.B.2" rel="Chapter" title="B.2 Shallue-Woestijne-Ulas Method">
<link href="#rfc.appendix.B.3" rel="Chapter" title="B.3 Simplified SWU Method">
<link href="#rfc.appendix.B.4" rel="Chapter" title="B.4 Elligator2 Method">
<link href="#rfc.authors" rel="Chapter">


  <meta name="generator" content="xml2rfc version 2.9.6 - https://tools.ietf.org/tools/xml2rfc" />
  <link rel="schema.dct" href="http://purl.org/dc/terms/" />

  <meta name="dct.creator" content="Sullivan, N. and C. Wood" />
  <meta name="dct.identifier" content="urn:ietf:id:draft-sullivan-hash-to-curve-latest" />
  <meta name="dct.issued" scheme="ISO8601" content="2018-03-02" />
  <meta name="dct.abstract" content="This document specifies a number of algorithms that may be used to hash arbitrary strings to Elliptic Curves." />
  <meta name="description" content="This document specifies a number of algorithms that may be used to hash arbitrary strings to Elliptic Curves." />

</head>

<body>

  <table class="header">
    <tbody>
    
    	<tr>
<td class="left">Network Working Group</td>
<td class="right">N. Sullivan</td>
</tr>
<tr>
<td class="left">Internet-Draft</td>
<td class="right">Cloudflare</td>
</tr>
<tr>
<td class="left">Intended status: Informational</td>
<td class="right">C. Wood</td>
</tr>
<tr>
<td class="left">Expires: September 3, 2018</td>
<td class="right">Apple Inc.</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">March 02, 2018</td>
</tr>

    	
    </tbody>
  </table>

  <p class="title">Hashing to Elliptic Curves<br />
  <span class="filename">draft-sullivan-hash-to-curve-latest</span></p>
  
  <h1 id="rfc.abstract"><a href="#rfc.abstract">Abstract</a></h1>
<p>This document specifies a number of algorithms that may be used to hash arbitrary strings to Elliptic Curves.</p>
<h1 id="rfc.status"><a href="#rfc.status">Status of This Memo</a></h1>
<p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p>
<p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF).  Note that other groups may also distribute working documents as Internet-Drafts.  The list of current Internet-Drafts is at https://datatracker.ietf.org/drafts/current/.</p>
<p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time.  It is inappropriate to use Internet-Drafts as reference material or to cite them other than as "work in progress."</p>
<p>This Internet-Draft will expire on September 3, 2018.</p>
<h1 id="rfc.copyrightnotice"><a href="#rfc.copyrightnotice">Copyright Notice</a></h1>
<p>Copyright (c) 2018 IETF Trust and the persons identified as the document authors.  All rights reserved.</p>
<p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license-info) in effect on the date of publication of this document.  Please review these documents carefully, as they describe your rights and restrictions with respect to this document.  Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p>

  
  <hr class="noprint" />
  <h1 class="np" id="rfc.toc"><a href="#rfc.toc">Table of Contents</a></h1>
  <ul class="toc">

  	<li>1.   <a href="#rfc.section.1">Introduction</a>
</li>
<ul><li>1.1.   <a href="#rfc.section.1.1">Requirements</a>
</li>
</ul><li>2.   <a href="#rfc.section.2">Algorithm Recommendations</a>
</li>
<li>3.   <a href="#rfc.section.3">Generic Interface</a>
</li>
<ul><li>3.1.   <a href="#rfc.section.3.1">Utility Functions</a>
</li>
</ul><li>4.   <a href="#rfc.section.4">Hashing Variants</a>
</li>
<ul><li>4.1.   <a href="#rfc.section.4.1">Icart Method</a>
</li>
<li>4.2.   <a href="#rfc.section.4.2">Shallue-Woestijne-Ulas Method</a>
</li>
<li>4.3.   <a href="#rfc.section.4.3">Simplified SWU Method</a>
</li>
<li>4.4.   <a href="#rfc.section.4.4">Elligator2 Method</a>
</li>
</ul><li>5.   <a href="#rfc.section.5">Curve Transformations</a>
</li>
<li>6.   <a href="#rfc.section.6">Cost Comparison</a>
</li>
<li>7.   <a href="#rfc.section.7">Security Considerations</a>
</li>
<li>8.   <a href="#rfc.section.8">Acknowledgements</a>
</li>
<li>9.   <a href="#rfc.section.9">Contributors</a>
</li>
<li>10.   <a href="#rfc.references">Normative References</a>
</li>
<li>Appendix A.   <a href="#rfc.appendix.A">Try-and-Increment Method</a>
</li>
<li>Appendix B.   <a href="#rfc.appendix.B">Sample Code</a>
</li>
<ul><li>B.1.   <a href="#rfc.appendix.B.1">Icart Method</a>
</li>
<li>B.2.   <a href="#rfc.appendix.B.2">Shallue-Woestijne-Ulas Method</a>
</li>
<li>B.3.   <a href="#rfc.appendix.B.3">Simplified SWU Method</a>
</li>
<li>B.4.   <a href="#rfc.appendix.B.4">Elligator2 Method</a>
</li>
</ul><li><a href="#rfc.authors">Authors' Addresses</a>
</li>


  </ul>

  <h1 id="rfc.section.1">
<a href="#rfc.section.1">1.</a> <a href="#introduction" id="introduction">Introduction</a>
</h1>
<p id="rfc.section.1.p.1">Many cryptographic protocols require a procedure which maps arbitrary input, e.g., passwords, to points on an elliptic curve (EC). Prominent examples include Simple Password Exponential Key Exchange <a href="#Jablon96" class="xref">[Jablon96]</a>, Password Authenticated Key Exchange <a href="#BMP00" class="xref">[BMP00]</a>, and Boneh-Lynn-Shacham signatures <a href="#BLS01" class="xref">[BLS01]</a>.</p>
<p id="rfc.section.1.p.2">Let E be an elliptic curve over base field GF(p). In practice, efficient (polynomial-time) functions that hash arbitrary input to E can be constructed by composing a cryptographically secure hash function F1 : {0,1}^* -&gt;GF(p) and an injection F2 : GF(p) -&gt; E, i.e., Hash(m) = F2(F1(m)).  Probabilistic constructions of Hash, e.g., the MapToGroup function described by Boneh et al.  <a href="#BLS01" class="xref">[BLS01]</a>. Their algorithm fails with probability 2^I, where I is a tunable parameter that one can control. Another variant, dubbed the &#8220;Try and Increment&#8221; approach, was described by Boneh et al. <a href="#BLS01" class="xref">[BLS01]</a>. This function works by hashing input m using a standard hash function, e.g., SHA256, and then checking to see if the resulting point E(m, f(m)), for curve function f, belongs on E.  This algorithm is expected to find a valid curve point after approximately two attempts, i.e., when ctr=1, on average. (See Appendix <a href="#try" class="xref">Appendix A</a> for a more detailed description of this algorithm.) Since the running time of the algorithm depends on m, this algorithm is NOT safe for cases sensitive to timing side channel attacks.  Deterministic algorithms are needed in such cases where failures are undesirable. Shallue and Woestijne <a href="#SWU" class="xref">[SWU]</a> first introduced a deterministic algorithm that maps elements in F_{q} to an EC in time O(log^4 q), where q = p^n for some prime p, and time O(log^3 q) when q = 3 mod 4. Icart introduced yet another deterministic algorithm which maps F_{q} to any EC where q = 2 mod 3 in time O(log^3 q) <a href="#Icart09" class="xref">[Icart09]</a>.  Elligator (2) <a href="#Elligator2" class="xref">[Elligator2]</a> is yet another deterministic algorithm for any odd-characteristic EC that has a point of order 2. Elligator2 can be applied to Curve25519 and Curve448, which are both CFRG-recommended curves <a href="#RFC7748" class="xref">[RFC7748]</a>.</p>
<p id="rfc.section.1.p.3">This document specifies several algorithms for deterministically hashing onto a curve with varying properties: Icart, SWU, Simplified SWU, and Elligator2.  Each algorithm conforms to a common  interface, i.e., it maps an element from a base field F to a curve E. For each variant, we describe the requirements for F and E to make it work. Sample code for each variant is presented in the appendix.  Unless otherwise stated, all elliptic curve points are assumed to be represented as affine coordinates, i.e., (x, y) points on a curve.</p>
<h1 id="rfc.section.1.1">
<a href="#rfc.section.1.1">1.1.</a> <a href="#requirements" id="requirements">Requirements</a>
</h1>
<p id="rfc.section.1.1.p.1">The key words &#8220;MUST&#8221;, &#8220;MUST NOT&#8221;, &#8220;REQUIRED&#8221;, &#8220;SHALL&#8221;, &#8220;SHALL NOT&#8221;, &#8220;SHOULD&#8221;, &#8220;SHOULD NOT&#8221;, &#8220;RECOMMENDED&#8221;, &#8220;MAY&#8221;, and &#8220;OPTIONAL&#8221; in this document are to be interpreted as described in <a href="#RFC2119" class="xref">[RFC2119]</a>.</p>
<h1 id="rfc.section.2">
<a href="#rfc.section.2">2.</a> <a href="#algorithm-recommendations" id="algorithm-recommendations">Algorithm Recommendations</a>
</h1>
<p id="rfc.section.2.p.1">The following table lists recommended algorithms to use for specific curves.</p>
<table cellpadding="3" cellspacing="0" class="tt full center">
<thead><tr>
<th class="left">Curve</th>
<th class="left">Algorithm</th>
</tr></thead>
<tbody>
<tr>
<td class="left">P-256</td>
<td class="left">SWU <a href="#simple-swu" class="xref">Section 4.3</a>
</td>
</tr>
<tr>
<td class="left">P-384</td>
<td class="left">Icart <a href="#icart" class="xref">Section 4.1</a>
</td>
</tr>
<tr>
<td class="left">Curve25519</td>
<td class="left">Elligator2 <a href="#elligator2" class="xref">Section 4.4</a>
</td>
</tr>
<tr>
<td class="left">Curve448</td>
<td class="left">Elligator2 <a href="#elligator2" class="xref">Section 4.4</a>
</td>
</tr>
</tbody>
</table>
<p id="rfc.section.2.p.2">The SWU variant from Section <a href="#swu" class="xref">Section 4.2</a> applies to any curve. As such, this algorithm SHOULD be used if no other better alternative is known. More efficient variants and their curve requirements are shown in the table below. These MAY be used if the target curve meets the listed criteria.</p>
<table cellpadding="3" cellspacing="0" class="tt full center">
<thead><tr>
<th class="left">Algorithm</th>
<th class="left">Requirement</th>
</tr></thead>
<tbody>
<tr>
<td class="left">Icart <a href="#icart" class="xref">Section 4.1</a>
</td>
<td class="left">p = 2 mod 3</td>
</tr>
<tr>
<td class="left">SWU <a href="#swu" class="xref">Section 4.2</a>
</td>
<td class="left">None</td>
</tr>
<tr>
<td class="left">Simplified SWU <a href="#simple-swu" class="xref">Section 4.3</a>
</td>
<td class="left">p = 3 mod 4</td>
</tr>
<tr>
<td class="left">Elligator2 <a href="#elligator2" class="xref">Section 4.4</a>
</td>
<td class="left">p is large and there is a point of order two and j-invariant != 1728</td>
</tr>
</tbody>
</table>
<h1 id="rfc.section.3">
<a href="#rfc.section.3">3.</a> <a href="#generic-interface" id="generic-interface">Generic Interface</a>
</h1>
<p id="rfc.section.3.p.1">The generic interface for hashing to elliptic curves is as follows:</p>
<pre>
hash_to_curve(alpha)
</pre>
<p id="rfc.section.3.p.2">where alpha is a message to hash onto a curve.</p>
<h1 id="rfc.section.3.1">
<a href="#rfc.section.3.1">3.1.</a> <a href="#utility-functions" id="utility-functions">Utility Functions</a>
</h1>
<p id="rfc.section.3.1.p.1">Algorithms in this document make use of utility functions described below.</p>
<p></p>

<ul>
<li>HashToBase(x): H(x)[0:log2(p) + 1], i.e., hash-truncate-reduce, where H is a cryptographic hash function, such as SHA256, and p is the prime order of base field Fp.</li>
<li>CMOV(a, b, c): If c = 1, return a, else return b.</li>
</ul>
<p id="rfc.section.3.1.p.3">Note: We assume that HashToBase maps its input to the base field uniformly.  In practice, there may be inherent biases in p, e.g., p = 2^k - 1 will have non-negligible bias in higher bits.</p>
<p id="rfc.section.3.1.p.4">((TODO: expand on this problem))</p>
<h1 id="rfc.section.4">
<a href="#rfc.section.4">4.</a> <a href="#hashing-variants" id="hashing-variants">Hashing Variants</a>
</h1>
<h1 id="rfc.section.4.1">
<a href="#rfc.section.4.1">4.1.</a> <a href="#icart" id="icart">Icart Method</a>
</h1>
<p id="rfc.section.4.1.p.1">The following hash_to_curve_icart(alpha) implements the Icart method from <a href="#Icart09" class="xref">[Icart09]</a>.  This algorithm works for any curve over F_{p^n}, where p^n = 2 mod 3 (or p = 2 mod 3 and for odd n), including:</p>
<p></p>

<ul>
<li>P384</li>
<li>Curve1174</li>
<li>Curve448</li>
</ul>
<p id="rfc.section.4.1.p.3">Unsupported curves include: P224, P256, P521, and Curve25519 since, for each, p = 1 mod 3.</p>
<p id="rfc.section.4.1.p.4">Mathematically, given input alpha, and A and B from E, the Icart method works as follows:</p>
<pre>
u = HashToBase(alpha)
x = (v^2 - b - (u^6 / 27))^(1/3) + (u^2 / 3)
y = ux + v
</pre>
<p id="rfc.section.4.1.p.5">where v = ((3A - u^4) / 6u).</p>
<p id="rfc.section.4.1.p.6">The following procedure implements this algorithm in a straight-line fashion.  It requires knowledge of A and B, the constants from the curve Weierstrass form.  It outputs a point with affine coordinates.</p>
<pre>
hash_to_curve_icart(alpha)

Input:

  alpha - value to be hashed, an octet string

Output:

  (x, y) - a point in E

Steps:

1.   u = HashToBase(alpha)   // {0,1}^* -&gt; Fp
2.  u2 = u^2 (mod p)         // u^2
3.  t2 = u2^2 (mod p)        // u^4
4.  v1 = 3 * A (mod p)       // 3A
5.  v1 = v1 - t2 (mod p)     // 3A - u^4
6.  t1 = 6 * u (mod p)       // 6u
7.  t3 = t1 ^ (-1) (mod p)   // modular inverse
8.   v = v1 * t3 (mod p)     // (3A - u^4)/(6u)
9.   x = v^2 (mod p)         // v^2
10.  x = x - B (mod p)       // v^2 - b
11. t1 = 27 ^ (-1) (mod p)   // 1/27
12. t1 = t1 * u2 (mod p)     // u^4 / 27
13. t1 = t1 * t2 (mod p)     // u^6 / 27
14.  x = x - t1 (mod p)      // v^2 - b - u^6/27
15. t1 = (2 * p) - 1 (mod p) // 2p - 1
16. t1 = t1 / 3 (mod p)      // (2p - 1)/3
17.  x = x^t1 (mod p)        // (v^2 - b - u^6/27) ^ (1/3)
18. t2 = u2 / 3 (mod p)      // u^2 / 3
19.  x = x + t2 (mod p)      // (v^2 - b - u^6/27) ^ (1/3) + (u^2 / 3)
20.  y = u * x (mod p)       // ux
21.  y = y + v (mod p)       // ux + v
22. Output (x, y)

</pre>
<h1 id="rfc.section.4.2">
<a href="#rfc.section.4.2">4.2.</a> <a href="#swu" id="swu">Shallue-Woestijne-Ulas Method</a>
</h1>
<p id="rfc.section.4.2.p.1">((TODO: write this section))</p>
<h1 id="rfc.section.4.3">
<a href="#rfc.section.4.3">4.3.</a> <a href="#simple-swu" id="simple-swu">Simplified SWU Method</a>
</h1>
<p id="rfc.section.4.3.p.1">The following hash_to_curve_simple_swu(alpha) implements the simplfied Shallue-Woestijne-Ulas algorithm from <a href="#SimpleSWU" class="xref">[SimpleSWU]</a>. This algorithm works for any curve over F_{p^n}, where p = 3 mod 4, including:</p>
<p></p>

<ul>
<li>P256</li>
<li>&#8230;</li>
</ul>
<p id="rfc.section.4.3.p.3">Given curve equation g(x) = x^3 + Ax + B, this algorithm works as follows:</p>
<pre>
1. t = HashToBase(alpha)
2. alpha = (-b / a) * (1 + (1 / (t^4 + t^2))) 
3. beta = &#8722;t^2 * alpha
4. z = t^3 * g(alpha)
5. Output (&#8722;g * alpha) * (g * beta)
</pre>
<p id="rfc.section.4.3.p.4">The following procedure implements this algorithm. It outputs a point with affine coordinates.</p>
<pre>
hash_to_curve_simple_swu(alpha)

Input:

  alpha - value to be hashed, an octet string

Output:

  (x, y) - a point in E

Steps:

1.     t = HashToBase(alpha)
2. alpha = t^2 (mod p)
3. alpha = alpha * -1 (mod p)
4. right = alpha^2 + alpha (mod p)
5. right = right^(-1) (mod p)
6. right = right + 1 (mod p)
7.  left = B * -1 (mod p)
8.  left = left / A (mod p) 
9.    x2 = left * right (mod p)
10.   x3 = alpha * x2 (mod p)
11.   h2 = x2 ^ 3 (mod p)
12.   i2 = x2 * A (mod p)
13.   i2 = i2 + B (mod p)
14.   h2 = h2 + i2 (mod p)
15.   h3 = x3 ^ 3 (mod p)
16.   i3 = x3 * A (mod p)
17.   i3 = i3 + B (mod p)
18.   h3 = h3 + i3 (mod p)
19.   y1 = h2 ^ ((p + 1) // 4) (mod p)
20.   y2 = h3 ^ ((p + 1) // 4) (mod p)
21.    e = (y1 ^ 2 == h2)
22.    x = CMOV(x2, x3, e)    // If e = 1, choose x2, else choose x3
23.    y = CMOV(y1, y2, e)    // If e = 1, choose y1, else choose y2
24. Output (x, y)
</pre>
<h1 id="rfc.section.4.4">
<a href="#rfc.section.4.4">4.4.</a> <a href="#elligator2" id="elligator2">Elligator2 Method</a>
</h1>
<p id="rfc.section.4.4.p.1">The following hash_to_curve_elligator2(alpha) implements the Elligator2 method from <a href="#Elligator2" class="xref">[Elligator2]</a>. This algorithm works for any curve with a point of order 2 and j-invariant != 1728. Given curve equation f(x) = y^2 = x(x^2 + Ax + B), i.e., a Montgomery form with the point of order 2 at (0,0), this algorithm works as shown below. (Note that any curve with a point of order 2 is isomorphic to this representation.)</p>
<pre>
1. r = HashToBase(alpha)
2. If f(-A/(1+ur^2)) is square, then output f(-A/(1+ur^2))^(1/2)
3. Else, output f(-Aur^2/(1+ur^2))^(1/2)
</pre>
<p id="rfc.section.4.4.p.2">Another way to express this algorithm is as follows:</p>
<pre>
1. r = HashToBase(alpha)
2. d = -A / (1 + ur^2)
3. e = f(d)^((p-1)/2)
4. u = ed - (1 - e)A/u
</pre>
<p id="rfc.section.4.4.p.3">Here, e is the Legendre symbol of y = (d^3 + Ad^2 + d), which will be 1 if y is a quadratic residue (square) mod p, and -1 otherwise.  (Note that raising y to ((p -1) / 2) is a common way to compute the Legendre symbol.)</p>
<p id="rfc.section.4.4.p.4">The following procedure implements this algorithm.</p>
<pre>
hash_to_curve_elligator2(alpha)

Input:

  alpha - value to be hashed, an octet string

  u - fixed non-square value in Fp.
  f() - Curve function

Output:

  (x, y) - a point in E

Steps:

1.   r = HashToBase(alpha)
2.   r = r^2 (mod p) 
3.  nu = r * u (mod p)
4.   r = nu
5.   r = r + 1 (mod p) 
6.   r = r^(-1) (mod p) 
7.   v = A * r (mod p) 
8.   v = v * -1 (mod p)   // -A / (1 + ur^2)
9.  v2 = v^2 (mod p)
10. v3 = v * v2 (mod p)
11.  e = v3 * v (mod p)
12. v2 = v2 * A (mod p)
13.  e = v2 * e (mod p)
14.  e = e^((p - 1) / 2)  // Legendre symbol
15. nv = v * -1 (mod p)
16.  v = CMOV(v, nv, e)   // If e = 1, choose v, else choose nv
17. v2 = CMOV(0, A, e)    // If e = 1, choose 0, else choose A
18.  u = v - v2 (mod p)
19. Output (u, f(u))
</pre>
<p id="rfc.section.4.4.p.5">Elligator2 can be simplified with projective coordinates.</p>
<p id="rfc.section.4.4.p.6">((TODO: write this variant))</p>
<h1 id="rfc.section.5">
<a href="#rfc.section.5">5.</a> <a href="#curve-transformations" id="curve-transformations">Curve Transformations</a>
</h1>
<p id="rfc.section.5.p.1">((TODO: write this section))</p>
<h1 id="rfc.section.6">
<a href="#rfc.section.6">6.</a> <a href="#cost-comparison" id="cost-comparison">Cost Comparison</a>
</h1>
<p id="rfc.section.6.p.1">The following table summarizes the cost of each hash_to_curve variant. We express this cost in terms of additions (A), multiplications (M), squares (SQ), and square roots (SR).</p>
<p id="rfc.section.6.p.2">((TODO: finish this section))</p>
<table cellpadding="3" cellspacing="0" class="tt full center">
<thead><tr>
<th class="left">Algorithm</th>
<th class="left">Cost (Operations)</th>
</tr></thead>
<tbody>
<tr>
<td class="left">hash_to_curve_icart</td>
<td class="left">TODO</td>
</tr>
<tr>
<td class="left">hash_to_curve_swu</td>
<td class="left">TODO</td>
</tr>
<tr>
<td class="left">hash_to_curve_simple_swu</td>
<td class="left">TODO</td>
</tr>
<tr>
<td class="left">hash_to_curve_elligator2</td>
<td class="left">TODO</td>
</tr>
</tbody>
</table>
<h1 id="rfc.section.7">
<a href="#rfc.section.7">7.</a> <a href="#security-considerations" id="security-considerations">Security Considerations</a>
</h1>
<p id="rfc.section.7.p.1">Each hash function variant accepts arbitrary input and maps it to a pseudorandom point on the curve. Points are close to indistinguishable from randomly chosen elements on the curve. Some variants variants are not full-domain hashes. Elligator2, for example, only maps strings to &#8220;about half of all curve points,&#8221; whereas Icart&#8217;s method only covers about 5/8 of the points.</p>
<h1 id="rfc.section.8">
<a href="#rfc.section.8">8.</a> <a href="#acknowledgements" id="acknowledgements">Acknowledgements</a>
</h1>
<p id="rfc.section.8.p.1">The authors would like to thank Adam Langley for this detailed writeup up Elligator2 with Curve25519 <a href="#ElligatorAGL" class="xref">[ElligatorAGL]</a>. We also thank Sean Devlin and Thomas Icart for feedback on earlier versions of this document.</p>
<h1 id="rfc.section.9">
<a href="#rfc.section.9">9.</a> <a href="#contributors" id="contributors">Contributors</a>
</h1>
<p></p>

<ul><li>Sharon Goldberg <br> Boston University <br> goldbe@cs.bu.edu</li></ul>
<h1 id="rfc.references">
<a href="#rfc.references">10.</a> Normative References</h1>
<table><tbody>
<tr>
<td class="reference"><b id="BLS01">[BLS01]</b></td>
<td class="top">"<a href="https://iacr.org/archive/asiacrypt2001/22480516.pdf">Short signatures from the Weil pairing</a>", n.d..</td>
</tr>
<tr>
<td class="reference"><b id="BMP00">[BMP00]</b></td>
<td class="top">"<a>Provably secure password-authenticated key exchange using diffie-hellman</a>", n.d..</td>
</tr>
<tr>
<td class="reference"><b id="ECOPRF">[ECOPRF]</b></td>
<td class="top">"<a>EC-OPRF - Oblivious Pseudorandom Functions using Elliptic Curves</a>", n.d..</td>
</tr>
<tr>
<td class="reference"><b id="Elligator2">[Elligator2]</b></td>
<td class="top">"<a href="https://dl.acm.org/ft_gateway.cfm?id=2516734&amp;type=pdf">Elligator -- Elliptic-curve points indistinguishable from uniform random strings</a>", n.d..</td>
</tr>
<tr>
<td class="reference"><b id="ElligatorAGL">[ElligatorAGL]</b></td>
<td class="top">"<a href="https://www.imperialviolet.org/2013/12/25/elligator.html">Implementing Elligator for Curve25519</a>", n.d..</td>
</tr>
<tr>
<td class="reference"><b id="Icart09">[Icart09]</b></td>
<td class="top">"<a href="https://eprint.iacr.org/2009/226.pdf">How to Hash into Elliptic Curves</a>", n.d..</td>
</tr>
<tr>
<td class="reference"><b id="Jablon96">[Jablon96]</b></td>
<td class="top">"<a>Strong password-only authenticated key exchange</a>", n.d..</td>
</tr>
<tr>
<td class="reference"><b id="RFC2119">[RFC2119]</b></td>
<td class="top">
<a>Bradner, S.</a>, "<a href="https://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997.</td>
</tr>
<tr>
<td class="reference"><b id="RFC7748">[RFC7748]</b></td>
<td class="top">
<a>Langley, A.</a>, <a>Hamburg, M.</a> and <a>S. Turner</a>, "<a href="https://tools.ietf.org/html/rfc7748">Elliptic Curves for Security</a>", RFC 7748, DOI 10.17487/RFC7748, January 2016.</td>
</tr>
<tr>
<td class="reference"><b id="RFC8017">[RFC8017]</b></td>
<td class="top">
<a>Moriarty, K.</a>, <a>Kaliski, B.</a>, <a>Jonsson, J.</a> and <a>A. Rusch</a>, "<a href="https://tools.ietf.org/html/rfc8017">PKCS #1: RSA Cryptography Specifications Version 2.2</a>", RFC 8017, DOI 10.17487/RFC8017, November 2016.</td>
</tr>
<tr>
<td class="reference"><b id="RFC8032">[RFC8032]</b></td>
<td class="top">
<a>Josefsson, S.</a> and <a>I. Liusvaara</a>, "<a href="https://tools.ietf.org/html/rfc8032">Edwards-Curve Digital Signature Algorithm (EdDSA)</a>", RFC 8032, DOI 10.17487/RFC8032, January 2017.</td>
</tr>
<tr>
<td class="reference"><b id="SECG1">[SECG1]</b></td>
<td class="top">"<a href="http://www.secg.org/sec1-v2.pdf">SEC 1 -- Elliptic Curve Cryptography</a>", n.d..</td>
</tr>
<tr>
<td class="reference"><b id="SimpleSWU">[SimpleSWU]</b></td>
<td class="top">"<a>Efficient Indifferentiable Hashing into Ordinary Elliptic Curves</a>", n.d..</td>
</tr>
<tr>
<td class="reference"><b id="SWU">[SWU]</b></td>
<td class="top">"<a href="https://arxiv.org/pdf/0706.1448">Rational points on certain hyperelliptic curves over finite fields</a>", n.d..</td>
</tr>
</tbody></table>
<h1 id="rfc.appendix.A">
<a href="#rfc.appendix.A">Appendix A.</a> <a href="#try" id="try">Try-and-Increment Method</a>
</h1>
<p id="rfc.section.A.p.1">In cases where constant time execution is not required, the so-called try-and-increment method may be appropriate. As discussion in Section <a href="#introduction" class="xref">Section 1</a>, this variant works by hashing input m using a standard hash function (&#8220;Hash&#8221;), e.g., SHA256, and then checking to see if the resulting point E(m, f(m)), for curve function f, belongs on E.  This is detailed below.</p>
<pre>
1. ctr = 0
3. h = "INVALID"
4. While h is "INVALID" or h is EC point at infinity:
   A.  CTR = I2OSP(ctr, 4)
   B.  ctr = ctr + 1
   C.  attempted_hash = Hash(m || CTR)
   D.  h = RS2ECP(attempted_hash)
   E.  If h is not "INVALID" and cofactor &gt; 1, set h = h^cofactor
5. Output h
</pre>
<p id="rfc.section.A.p.2">I2OSP is a function that converts a nonnegative integer to octet string as defined in Section 4.1 of <a href="#RFC8017" class="xref">[RFC8017]</a>, and RS2ECP is a function that converts of a random 2n-octet string to an EC point as specified in Section 5.1.3 of <a href="#RFC8032" class="xref">[RFC8032]</a>.</p>
<h1 id="rfc.appendix.B">
<a href="#rfc.appendix.B">Appendix B.</a> <a href="#sample-code" id="sample-code">Sample Code</a>
</h1>
<h1 id="rfc.appendix.B.1">
<a href="#rfc.appendix.B.1">B.1.</a> <a href="#icart-method" id="icart-method">Icart Method</a>
</h1>
<p id="rfc.section.B.1.p.1">The following Sage program implements hash_to_curve_icart(alpha) for P-384.</p>
<pre>
p = 39402006196394479212279040100143613805079739270465446667948293404245721771496870329047266088258938001861606973112319
F = GF(p)
A = p - 3
B = 0xb3312fa7e23ee7e4988e056be3f82d19181d9c6efe8141120314088f5013875ac656398d8a2ed19d2a85c8edd3ec2aef
q = 39402006196394479212279040100143613805079739270465446667946905279627659399113263569398956308152294913554433653942643
E = EllipticCurve([F(A), F(B)])
g = E(0xaa87ca22be8b05378eb1c71ef320ad746e1d3b628ba79b9859f741e082542a385502f25dbf55296c3a545e3872760ab7, \
    0x3617de4a96262c6f5d9e98bf9292dc29f8f41dbd289a147ce9da3113b5f0b8c00a60b1ce1d7e819d7a431d7c90ea0e5f)
E.set_order(q)

def icart(u):
  u = F(u)
  v = (3*A - u^4)//(6*u)
  x = (v^2 - B - u^6/27)^((2*p-1)//3) + u^2/3
  y = u*x + v
  return E(x, y) 

def icart_straight(u):
    u = F(u)
    u2 = u ^ 2
    t2 = u2 ^ 2
    assert t2 == u^4

    v1 = 3 * A
    v1 = v1 - t2
    t1 = 6 * u
    t3 = t1 ^ (-1)
    v = v1 * t3
    assert v == (3 * A - u^4) // (6 * u)

    x = v ^ 2
    x = x - B
    assert x == (v^2 - B)

    t1 = F(27) ^ (-1)
    t1 = t1 * u2
    t1 = t1 * t2
    assert t1 == ((u^6) / 27)
    
    x = x - t1
    t1 = (2 * p) - 1
    t1 = t1 / 3
    assert t1 == ((2*p) - 1) / 3

    x = x ^ t1
    
    t2 = u2 / 3
    x = x + t2
    y = u * x
    y = y + v
    return E(x, y)
</pre>
<h1 id="rfc.appendix.B.2">
<a href="#rfc.appendix.B.2">B.2.</a> <a href="#shallue-woestijne-ulas-method" id="shallue-woestijne-ulas-method">Shallue-Woestijne-Ulas Method</a>
</h1>
<p id="rfc.section.B.2.p.1">((TODO: write this section))</p>
<h1 id="rfc.appendix.B.3">
<a href="#rfc.appendix.B.3">B.3.</a> <a href="#simplified-swu-method" id="simplified-swu-method">Simplified SWU Method</a>
</h1>
<p id="rfc.section.B.3.p.1">The following Sage program implements hash_to_curve_swu(alpha) for P-256.</p>
<pre>
p = 115792089210356248762697446949407573530086143415290314195533631308867097853951
F = GF(p)
A = F(p - 3)
B = F(ZZ("5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b", 16))
E = EllipticCurve([A, B])

def simple_swu(alpha):
    t = F(alpha)
    
    alpha = -(t^2)
    frac = (1 / (alpha^2 + alpha))
    x2 = (-B / A) * (1 + frac)
    
    x3 = alpha * x2
    h2 = x2^3 + A * x2 + B
    h3 = x3^3 + A * x3 + B

    if is_square(h2):
        return E(x2, h2^((p + 1) // 4))
    else:
        return E(x3, h3^((p + 1) // 4))

def simple_swu_straight(alpha):
    t = F(alpha)
    
    alpha = t^2
    alpha = alpha * -1
    
    right = alpha^2 + alpha
    right = right^(-1)
    right = right + 1

    left = B * -1
    left = left / A

    x2 = left * right
    x3 = alpha * x2

    h2 = x2 ^ 3
    i2 = x2 * A
    i2 = i2 + B
    h2 = h2 + i2

    h3 = x3 ^ 3
    i3 = x3 * A
    i3 = i3 + B
    h3 = h3 + i3

    y1 = h2^((p + 1) // 4)
    y2 = h3^((p + 1) // 4)

    # Is it square?
    e = y1^2 == h2

    x = x2
    if e != 1:
        x = x3
    
    y = y1
    if e != 1:
        y = y2

    return E(x, y)
</pre>
<h1 id="rfc.appendix.B.4">
<a href="#rfc.appendix.B.4">B.4.</a> <a href="#elligator2-method" id="elligator2-method">Elligator2 Method</a>
</h1>
<p id="rfc.section.B.4.p.1">The following Sage program implements hash_to_curve_elligator2(alpha) for Curve25519.</p>
<pre>
p = 2**255 - 19
F = GF(p)
A = 486662
B = 1
E = EllipticCurve(F, [0, A, 0, 1, 0])

def curve25519(x):
    return x^3 + (A * x^2) + x

def elligator2(alpha):

    r = F(alpha)

    # u is a fixed nonsquare value, eg -1 if p==3 mod 4.
    u = F(2) # F(2)
    assert(not u.is_square())
    
    # If f(-A/(1+ur^2)) is square, return its square root.
    # Else, return the square root of f(-Aur^2/(1+ur^2)).
    x = -A / (1 + (u * r^2))
    y = curve25519(x)
    if y.is_square(): # is this point square?
        y = y.square_root()
    else:
        x = (-A * u * r^2) / (1 + (u * r^2))
        y = curve25519(x).square_root()
    
    return (x, curve25519(x))

def elligator2_straight(alpha):
    r = F(alpha)

    r = r^2
    r = r * 2
    r = r + 1
    r = r^(-1)
    v = A * r
    v = v * -1 # d

    v2 = v^2
    v3 = v * v2
    e = v3 + v
    v2 = v2 * A
    e = v2 + e

    # Legendre symbol
    e = e^((p - 1) / 2)

    nv = v * -1
    if e != 1:
        v = nv

    v2 = 0
    if e != 1:
        v2 = A
    
    u = v - v2
    
    return (u, curve25519(u))
</pre>
<h1 id="rfc.authors"><a href="#rfc.authors">Authors' Addresses</a></h1>
<div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Nick Sullivan</span> 
	  <span class="n hidden">
		<span class="family-name">Sullivan</span>
	  </span>
	</span>
	<span class="org vcardline">Cloudflare</span>
	<span class="adr">
	  <span class="vcardline">101 Townsend St</span>

	  <span class="vcardline">
		<span class="locality">San Francisco</span>,  
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline">United States of America</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:nick@cloudflare.com">nick@cloudflare.com</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Christopher A. Wood</span> 
	  <span class="n hidden">
		<span class="family-name">Wood</span>
	  </span>
	</span>
	<span class="org vcardline">Apple Inc.</span>
	<span class="adr">
	  <span class="vcardline">One Apple Park Way</span>

	  <span class="vcardline">
		<span class="locality">Cupertino, California 95014</span>,  
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline">United States of America</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:cawood@apple.com">cawood@apple.com</a></span>

  </address>
</div>

</body>
</html>
